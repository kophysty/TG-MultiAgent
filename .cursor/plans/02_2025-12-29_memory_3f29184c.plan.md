---
name: 02_2025-12-29_memory
overview: "Добавляем модуль Memory and Preferences: Postgres schema + двусторонний sync с Notion (editable UI) + сводка профиля + инъекция предпочтений в prompt планера, с write-through в Notion и ретраями."
todos:
  - id: notion-db-setup
    content: "Создать на странице User-preferences две Notion базы: Preferences и Preference Profiles, с согласованными полями (ExternalId, ChatId, ValueHuman/ValueJson, SyncHash, Summary)."
    status: pending
  - id: pg-migrations-memory
    content: Добавить миграции Postgres для preferences, preferences_sync, notion_sync_queue и применить их в dev окружении.
    status: pending
  - id: repos-memory
    content: Реализовать PreferencesRepo (Postgres) и PreferencesNotionRepo (Notion) для upsert, list, sync метаданных и очереди ретраев.
    status: pending
  - id: worker-memory-sync
    content: "Расширить apps/reminders_worker: добавить memoryTick pull из Notion и обработку notion_sync_queue для write-through push в Notion с backoff."
    status: pending
  - id: planner-memory-injection
    content: Подмешать memorySummary в core/ai/agent_planner.js и подключить получение summary в core/dialogs/todo_bot.js перед планированием.
    status: pending
  - id: docs-memory-ru
    content: Добавить docs/current/memory.md и обновить docs/current/index.md (RU) под новый модуль.
    status: pending
---

#План: Memory and Preferences (Postgres + Notion двусторонний sync)

## Цель

Сделать накопительный слой предпочтений пользователя (по `chat_id`) с быстрым чтением из Postgres, витриной и ручным редактированием через Notion.

## Решение уровня архитектуры

- **Postgres** - источник для быстрого чтения и инъекции в prompt
- **Notion** - UI для просмотра и ручного редактирования
- **Приоритет изменений**
- если пользователь изменил/создал/архивировал preference в Notion - воркер синхронизирует в Postgres и это считается источником правды для этого preference
- если preference изменился в Postgres - делаем write-through апдейт в Notion, при ошибке пишем retry и пробуем позже

## Структура Notion (создаем на странице User-preferences)

Parent page: `2d6535c900f080bda11afb55570e674c` (из ссылки пользователя)

### 1) Data source: Preferences

- **Title**: `Key` (например `timezone`, `daily_digest_silent`)
- **ExternalId** (rich_text): `pref:<chat_id>:<scope>:<key>` (уникально, используется для upsert)
- **ChatId** (number)
- **Scope** (select): `global` (по умолчанию), `project` (на будущее)
- **Category** (select): `lifestyle`, `work`, `dev`, `content`, `other`
- **Active** (checkbox): по умолчанию true
- **ValueHuman** (rich_text): кратко читаемое значение
- **ValueJson** (rich_text): JSON строкой (если не JSON, храним как строку)
- **UpdatedAt** (date): последняя правка пользователем или sync
- **SyncHash** (rich_text): хеш нормализованного значения, чтобы не делать лишние апдейты
- **LastSource** (select): `notion` или `postgres`

### 2) Data source: Preference Profiles

- **Title**: `Chat <chat_id>`
- **ExternalId** (rich_text): `profile:<chat_id>`
- **ChatId** (number)
- **Summary** (rich_text): сжатая сводка (10-30 строк)
- **UpdatedAt** (date)

## Структура Postgres

Новые миграции в `infra/db/migrations/`:

- `003_preferences.sql`
- таблица `preferences`
    - `chat_id bigint`
    - `scope text` (default `global`)
    - `category text`
    - `pref_key text`
    - `value_json jsonb`
    - `value_human text`
    - `active boolean`
    - `source text` (`notion`|`postgres`)
    - `updated_at timestamptz`, `created_at timestamptz`
    - unique `(chat_id, scope, pref_key)`
- `004_preferences_sync.sql`
- таблица `preferences_sync`
    - `external_id text primary key`
    - `chat_id bigint`
    - `pref_key text`, `scope text`
    - `notion_page_id text`
    - `last_pushed_hash text`
    - `last_pushed_at timestamptz`
    - `last_seen_notion_edited_at timestamptz`
- `005_notion_sync_queue.sql`
- таблица `notion_sync_queue`
    - `id bigserial`
    - `kind text` (`pref_page_upsert`|`profile_upsert`)
    - `external_id text`
    - `payload jsonb`
    - `attempt int`, `next_run_at timestamptz`, `last_error text`
    - уникальность по `(kind, external_id)` чтобы схлопывать повторные апдейты

## Кодовые изменения

### 1) Repo слой

- Добавить `core/connectors/postgres/preferences_repo.js`
- `upsertPreference`, `listPreferencesForChat`, `markInactive`, `getByExternalId`
- методы для `notion_sync_queue` (enqueue, claimBatch, markDone, reschedule)

### 2) Notion connector (минимальный)

- Добавить `core/connectors/notion/preferences_repo.js`
- `findPreferencePageByExternalId`, `upsertPreferencePage`, `listRecentlyEditedPreferences`
- `upsertProfilePage`

### 3) Worker: двусторонний sync

Используем текущий воркер как базу: [apps/reminders_worker/src/main.js](apps/reminders_worker/src/main.js)

- Добавить второй цикл `memoryTick()` с периодом `TG_MEMORY_SYNC_SECONDS` (например 300)
- Логика pull из Notion:
- query Preferences DB (с сортировкой по `last_edited_time` если доступно, иначе постранично)
- для каждой страницы:
    - собрать `externalId`, `chatId`, `key`, `valueHuman`, `valueJson`, `active`
    - вычислить `hash`
    - если `hash` отличается от `last_pushed_hash` и `last_edited_time` новее - upsert в Postgres как `source=notion`
    - если `active=false` или `archived=true` - пометить preference неактивным в Postgres
- Логика push в Notion (write-through с ретраями):
- при изменениях в Postgres писать в `notion_sync_queue`
- воркер берет пачку задач из queue и делает upsert в Notion
- на успех обновляет `preferences_sync.last_pushed_hash/at`
- на ошибку reschedule с экспоненциальной задержкой

### 4) Инъекция предпочтений в prompt планера

- Расширить `planAgentAction` в [core/ai/agent_planner.js](core/ai/agent_planner.js):
- принимать `memorySummary` (строка)
- добавлять блок в user content перед `User message:` вида `User preferences:`
- В [core/dialogs/todo_bot.js](core/dialogs/todo_bot.js):
- перед вызовом `planAgentAction` получать preferences summary из Postgres (краткий формат)

## Конфигурация (env)

- `NOTION_PREFERENCES_DB_ID`
- `NOTION_PREFERENCE_PROFILES_DB_ID`
- `TG_MEMORY_SYNC_SECONDS` (default 300)
- `TG_MEMORY_PUSH_BATCH` (default 20)

## Документация (RU)

- Добавить `docs/current/memory.md`
- Обновить `docs/current/index.md` ссылкой на memory

## Проверка

- Создать preference в Postgres через бота (временная команда или прямой вызов) и убедиться, что в Notion появилась запись
- Отредактировать `ValueHuman` или `ValueJson` в Notion и убедиться, что Postgres обновился