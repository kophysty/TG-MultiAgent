---
name: 09_2026-01-12_subagents_orch
overview: Сравнение текущего флоу (один AI planner + детерминированные ветки) и архитектуры с оркестратором и субагентами. Цель - понять, что меняется, где сохраняются детерминированные проверки, и почему многоагентность дает ощущение "магии".
todos:
  - id: define-router
    content: Определить критерии роутинга (intent classifier или router-model) и домены субагентов.
    status: pending
  - id: agent-contracts
    content: Описать контракт данных между оркестратором и субагентами (context, history, lastShown, ids).
    status: pending
  - id: tool-bundles-hybrid
    content: Оценить гибридный вариант (динамические tool bundles без полноценной многоагентности).
    status: pending
---

## Контекст

Сейчас бот работает как "один AI planner" с большим набором инструментов и набором детерминированных веток:

- Telegram команды `/...` обрабатываются детерминированно (regex handlers).
- Security (admin-only) определяется детерминированно по `chat_id`.
- Есть специальные детерминированные гейты для UX и безопасности (пример - preferences с кнопками Да/Нет).
- Если сообщение не попало в команды и гейты, оно уходит в AI planner, который возвращает либо chat, либо tool plan.

### Почему возникает ощущение, что "фильтр выбирает инструменты"

Это ощущение появляется, когда:

- гейт не сработал
- сообщение ушло в обычный AI диалог
- модель написала текст "сохранил", но tool реально не вызывался и запись в Postgres не появилась

То есть проблема часто не в "модель не понимает синонимы", а в том, что нужный сценарий не был активирован до planner слоя.

## Схема 1 - текущая архитектура (один agent + детерминированные ветки)

```text
Telegram msg
  -> (voice?) STT -> text
  -> security check (admin?)
  -> if "/command" -> command handler (deterministic)
  -> else:
       -> pre-gates (preferences intent? admin memory intent? etc)
       -> if gate matched -> special flow (UI buttons / deterministic handler)
       -> else -> AI planner:
             -> returns { chat } OR { tool + args }
             -> tool executor -> bot reply
```

### Где тут "рельсы"

- `/command` роутинг (детерминированный, надежный, дешевый)
- security check (admin-only)
- pre-gates для чувствительных сценариев (например preferences confirm)
- system prompt правила (частично ограничивают выбор tools)

### Плюсы

- проще поддерживать как MVP
- меньше компонентов, меньше наблюдаемости и дебага
- быстрее по latency (одна модельная точка решения)

### Минусы

- planner видит сразу много доменов и tools
- растет вероятность промаха в выборе tool или аргументов
- если UX сценарий не активирован, модель может "сказать" вместо "сделать"

## Схема 2 - оркестратор + субагенты (multi-agent)

Идея: вынести выбор домена в отдельный слой "оркестратор", а внутри домена дать узкому агенту небольшой набор tools.

```text
Telegram msg
  -> (voice?) STT -> text
  -> security check (admin?)
  -> if "/command" -> command handler (deterministic)
  -> else:
       -> (optional) safety pre-gates (например preferences confirm)
       -> Orchestrator (router model OR lightweight classifier):
             -> chooses 1 domain agent:
                  - TasksAgent (tools: list/create/update/done/deprecate)
                  - SocialAgent (tools: social list/create/update/archive)
                  - IdeasAgent
                  - JournalAgent
                  - MemoryAgent (chat summary/find/chat_at, prefs, etc)
             -> chosen agent plans + calls its small toolset
             -> result -> bot reply
```

### Что остается детерминированным почти всегда

- Telegram команды `/...`
- security check (admin-only)
- часть safety и UX гейтов, где важнее надежность и предсказуемость, чем "интуиция" модели

То есть многоагентность обычно не отменяет детерминированные проверки, она уменьшает их долю и делает их более локальными.

### Почему это дает ощущение "магии"

- каждый агент видит только свой маленький набор tools
- меньше неоднозначностей и меньше шансов выбрать не тот домен
- проще сделать качественный system prompt и few-shot примеры под конкретный домен

### Плюсы

- выше точность выбора действий без большого числа ручных правил
- легче масштабировать: добавил новый домен, добавил нового агента
- проще sandbox по безопасности: агент физически не может вызвать tools, которых у него нет

### Минусы

- сложнее инфраструктура: больше логов, трассировки, контракты, маршрутизация
- выше latency: router плюс агент (иногда 2 модельных вызова)
- нужно аккуратно проектировать "общий контекст" (history, memory, lastShown, ids)

## Почему в n8n часто "все проще"

Частый паттерн n8n:

- оркестрация детерминированная графом шагов
- AI точечно решает узкие задачи: извлечь поля, классифицировать, сгенерировать текст

Это ближе к многоагентной архитектуре с оркестратором, чем к модели "один агент решает все".

## Гибридный вариант (без полноценной многоагентности)

Цель: получить часть преимуществ субагентов без полной перестройки.

Идея: один planner, но "tool bundles":

- сначала lightweight классификация интента или домена
- затем в planner передается только релевантный поднабор tools

Это снижает вероятность промаха и часто убирает потребность в части детерминированных "оберток".

## Рекомендованный путь миграции (если решим идти в субагентов)

1) Ввести router слой (самый простой - classifier по доменам).
2) Ввести 2-3 субагента для самых частых доменов (например Tasks, Social, Memory).
3) Вынести tool registry по доменам и запретить лишние tools в каждом агенте.
4) Добавить трассировку: trace_id от входа до tool call, чтобы дебаг не стал болью.
5) Постепенно переносить правила и system prompt в доменные агенты, упрощая общий planner.

## Открытые вопросы

- Как делить контекст между router и субагентами: давать ли субагентам полный chatHistory или только summary плюс last N.
- Что считать "MemoryAgent": включает ли он preferences, chat memory команды, execution_history, errors.
- Где хранить "last shown list" и "draft state": единый state store или per agent.

