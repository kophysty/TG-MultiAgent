# DevOps - подводные камни и как не делать

Этот документ - накопительная база негативного опыта: что уже ломалось, почему, и как не повторять.

## JS regex: не использовать word boundary для кириллицы

### Симптомы

- Бот "не понимает" русские формулировки, хотя слова явно присутствуют в тексте.
- Интент-детекторы на ключевых словах не срабатывают (например, дневник, запись, сегодня, завтра).
- Поведение плавает: одна и та же фраза то срабатывает, то нет.

### Причина

В JavaScript word boundary (backslash-b) опирается на понятие "word char" (backslash-w), а оно по умолчанию ASCII-only.
Кириллица не считается word char, поэтому границы слова для русских слов определяются неправильно.

### Как правильно

- Для русских ключевых слов:
  - использовать простые проверки `includes` по `lowercase` строке, или
  - использовать regex без word boundary, или
  - использовать Unicode-aware границы на `\\p{L}` и `\\p{N}` (с флагом `u`), если реально нужна точность.
- Для слов, где есть пересечения (например, "послезавтра" содержит "завтра"):
  - важен порядок проверок: сначала длинное, потом короткое.

### Где уже починено

- `core/dialogs/todo_bot.js` и `core/dialogs/todo_bot_helpers.js`:
  - journal intent детекторы
  - распознавание "сегодня/завтра/послезавтра"
  - эвристики для списков и части journal inference

## JS regex: backslash-w и backslash-W тоже ASCII-only и ломают разбор русских voice фраз

### Симптомы

- Voice текст на русском "съедается" regex-заменами, остаются обрывки ("4 единицы" вместо "автоматик 4 единицы").
- Разбор списков по "и" превращается в мусорные пункты и запускает лишние ветки действий.

### Причина

В JavaScript `\\w` и `\\W` по умолчанию ASCII-only. Кириллица не считается `\\w`, поэтому:

- `\\W*` может удалить русские слова как будто это "пунктуация"
- любые "word boundary" и похожие эвристики ведут себя нестабильно на RU

### Как правильно

- Не использовать `\\W` и `\\w` для разборов на русском.
- Для "пробелы или пунктуация" использовать Unicode property classes с флагом `u`:
  - например `[\p{P}\p{S}\s]+` вместо `\\W+`
- Для разборов voice списков:
  - включать split по "и" только если реально есть признаки списка (запятые, "потом/затем", и т.д.)
  - не использовать `:` как разделитель, если в тексте может быть время `HH:MM`

## Telegram polling: утечка токена в логах через вывод объекта ошибки

### Симптомы

- В терминале появляется огромный объект ошибки, где в полях `request/response` есть URL вида `https://api.telegram.org/bot<TOKEN>/getUpdates`.
- Ошибка часто выглядит как:
  - `409 Conflict: terminated by other getUpdates request`
  - сетевые ошибки (например `ECONNRESET`)

### Причина

В Telegram Bot API токен находится прямо в URL. Если вывести в `console.error` целиком объект ошибки (или объект запроса), токен попадет в логи.

### Как правильно

- Никогда не логировать целиком объект ошибки или объект запроса.
- Логировать только безопасные поля: `code`, `message`, `description`.
- Маскировать подстроки вида `bot<TOKEN>` в любых строках перед логированием.
- Если токен уже засветился в логах, лучше перевыпустить его через BotFather.

## Agent routing: почему детерминированные обертки и списки ключевых слов - тупиковый путь (2026-01-12)

### Симптомы

- Фраза "запомни" или "добавь в память" часто не запускает нужный flow, особенно после STT (ошибки, склейки, падежи).
- Для корректной работы приходится постоянно дописывать детерминированные эвристики и списки синонимов.
- Поведение не нативное: модель отвечает "как будто запомнила", но фактически не вызван tool и нет UI подтверждения Да/Нет.
- С ростом количества tools выбор становится менее стабильным, и мы компенсируем это еще большим количеством оберток.

### Причина

Мы пытаемся детерминированно решать задачу, которая по природе вероятностная:

- входные данные шумные (voice, ошибки транскрибации)
- язык естественный, вариативный (синонимы, формы слов, порядок)
- множество инструментов конкурируют за интерпретацию (tools растут, а эвристики ломаются чаще)

В итоге "pre-гейты" начинают подменять оркестрацию, и проект уходит в бесконечные исключения и правки regex.

### Почему это плохой путь

- Не масштабируется: каждая новая команда или интент требует новых фильтров, исключений и регекспов.
- Особенно ломается на русском и voice: границы слов, склейки слов, Unicode pitfalls, шум транскрибации.
- Противоречит ожиданию "как Claude Code": семантический выбор действий, а не угадайка по ключевым словам.

### Сравнение с N8N (почему там кажется проще)

- В N8N оркестрация отделена от исполнения: есть routing между шагами.
- Интеграции работают как "проводка", а не как попытка одним набором эвристик распознать все возможные формулировки.
- Ожидание: у нас должен быть такой же слой маршрутизации, только внутри core.

### Как правильно

Минимальная иерархия:

- Router-оркестратор (LLM) решает: какой домен задачи и какой набор tools релевантен.
- Planner-исполнитель (LLM) строит plan и вызывает tools строго внутри выбранного набора.
- Код отвечает за безопасность и необратимые операции:
  - запись preferences только после Да
  - slash-команды и security gates остаются детерминированными

### Критерии успеха

- "запомни ..." с кривой транскрибацией стабильно приводит к UI подтверждения Да/Нет или к уточняющему вопросу.
- Меньше детерминированных pre-фильтров, меньше "магии" в регексах, меньше ветвлений по словам.
- Нельзя получить ответ "сохранил", если tool реально не был вызван.


