# AI (текущая реализация)

Этот раздел описывает, что реально умеет AI в текущей версии бота.

## Что AI делает

- Определяет тип сообщения:
  - **вопрос** - отвечает прямо в чат
  - **задача** - извлекает поля задачи, показывает summary и просит подтверждение

## Подтверждение и корректировки

После того как бот показал summary задачи:

- Подтвердить можно:
  - кнопкой **Подтвердить**
  - текстом: **"да"**, **"подтверждаю"**, **"подтвердить"**, **"ок"**
- Отменить можно:
  - кнопкой **Отмена**
  - текстом: **"нет"**, **"отмена"**, **"отменить"**
- Любой другой текст считается уточнением: бот пересобирает черновик задачи и снова просит подтверждение.

## Категории (Tags) и ограничения

- Категории берутся **динамически** из Notion свойства **`Tags`** (options).
- AI **не имеет права** придумывать новые категории:
  - в prompt передается список допустимых категорий
  - если AI сомневается - выбирает **`Inbox`**
- `Deprecated`:
  - AI не выбирает эту категорию
- Алиас `Today`:
  - в UI может отображаться как `Today`
  - в Notion фактически используется тег **`Inbox`** (алиас Today - Inbox)
- `Every Day`:
  - можно выбирать для периодических задач-напоминаний

## Инструменты (что реально используется)

- **Telegram polling**: получение апдейтов через `node-telegram-bot-api`.
- **Notion Tasks CRUD**: создание и чтение задач через Notion API (`core/connectors/notion`).
- **OpenAI**: анализ текста и выдача структурированного JSON для вопрос/задача и полей задачи.

## OpenAI API: Chat Completions и Responses API

В коде бота важно различать два уровня:

- **API формат и протокол**: как мы вызываем модель (какой endpoint), и какой формат ответа ожидаем (structured JSON, tool calls и т.д.).
- **Память**: это не свойство "модели по умолчанию". Память появляется только если ты сам передаешь историю, или используешь отдельные продуктовые абстракции (например thread) и хранишь состояние там.

### Chat Completions API (`/v1/chat/completions`)

Это классический endpoint "messages -> completion".

- Контекст и история: **только то, что ты сам передал** в `messages`.
- В нашей кодовой базе используется structured JSON формат ответа, чтобы надежно строить планы и вызывать tools.

### Responses API (`/v1/responses`)

Это более новый унифицированный endpoint для ответов и tool поведения.

- Его удобно использовать для сценариев типа "ответить текстом и при необходимости дернуть встроенный поиск" (например web_search).
- Наличие "внутренней памяти" не гарантируется само по себе. Для надежной памяти мы продолжаем хранить summary и историю в Postgres и инжектить их в контекст модели.

### Почему structured формат важен

Для бота, который вызывает tools и меняет данные (Notion, Postgres), structured формат снижает вероятность:

- ошибки парсинга
- дрейфа схемы аргументов между моделями
- неожиданных действий из-за неоднозначного текста

## Observability (event_log и trace_id)

Для расследований "почему бот сделал именно так" есть операционный лог в Postgres - таблица `event_log`.

- Каждый входящий апдейт получает `trace_id` (AsyncLocalStorage).
- По `trace_id` можно собрать цепочку:
  - `incoming_message` / `incoming_callback`
  - `planner_plan`
  - `tool_call` (executor)
  - `notion_request` / `notion_response` / `notion_error`
  - `tg_send` (outbound)

Важно:

- В `event_log.payload` пишем только sanitized данные (без токенов, заголовков, cookies).

## Запросы списков и работа с Notion (tools)

Если AI включен (`TG_AI=1`), бот умеет принимать естественные запросы вида:

- "покажи задачи"
- "покажи инбокс"
- "покажи домашние"
- "покажи задачи на сегодня"
- "покажи задачи про X" / "список задач по слову X" - использует `list_tasks` с фильтром по тексту (не `find_tasks`)
- "пометь 3 как выполненную"
- "удали задачу X" (фактически переносит в `Deprecated`)
- "покажи идеи"
- "добавь идею: ..."
- "удали идею X" (архивирует запись)
- "покажи посты tiktok"
- "добавь пост в tiktok: ..."
- "удали пост X" (архивирует запись)
- "добавь запись в дневник: ..."
- "покажи записи дневника за сегодня"
- "обнови запись дневника X"
- "удали запись дневника X" (архивирует запись)

### Фильтры по умолчанию

- По умолчанию в списках **не показываются** выполненные задачи (`Done`).
- Выполненные показываются только если явно попросить:
  - "покажи выполненные" - покажет только `Done`
  - "покажи все включая выполненные" - покажет все статусы

### Подтверждение tool-действий

Для действий, которые меняют данные (например: пометить выполненным, перенести в Deprecated, обновить задачу, добавить описание) бот просит подтверждение:

- кнопками **Подтвердить** / **Отмена**
- или текстом (fallback): "да" / "нет"

Также подтверждение используется при дедупликации:

- если при создании задачи, идеи, поста или записи дневника найдено точное совпадение по названию, бот спросит, создавать ли дубль.

### Summary после создания записей

После успешного создания задачи, идеи, поста или записи дневника бот показывает детальный summary:

- база данных (Tasks main/test, Ideas, Social, Journal)
- категория/теги/платформа
- статус, приоритет, даты
- ссылка на страницу в Notion

Формат: многострочное текстовое сообщение без inline кнопок.

### Синонимы категорий

- "инбокс", "входящие", "today" - категория `Inbox` (в UI может отображаться как `Today`)
- "домашние" - категория `Home`
- "рабочие", "работа" - категория `Work`

### "На сегодня"

- Фраза "задачи на сегодня" означает: задачи с due date = сегодня (по `TG_TZ`) плюс задачи из `Inbox`.

### Даты для списков задач: "на завтра" и "на число"

Когда пользователь просит список задач на конкретную дату, бот старается детерминированно превратить формулировку в `dueDate` и отфильтровать задачи по этой дате (в таймзоне `TG_TZ`).

Поддерживается:

- "на завтра"
  - вычисляется как "текущая дата в `TG_TZ` + 1 день"
- "на послезавтра"
  - вычисляется как "текущая дата в `TG_TZ` + 2 дня"
- "на 8-е" / "на 8 число" / "на восьмое"
  - трактуется как ближайшее наступление указанного числа месяца
  - если сегодня уже 8-е или позже, будет выбран следующий месяц (и год переключится при переходе через декабрь)
- "на 11 февраля" / "на 5 декабря" / "на 9 января"
  - если указанная дата в текущем году уже прошла, будет выбран следующий год

Примеры:

- "Покажи задачи на завтра"
- "Покажи задачи на 8-е число"
- "Покажи рабочие задачи на 11 февраля"

### Задачи "на этой неделе" и "на следующей неделе"

Бот понимает запросы по диапазону дат, отталкиваясь от текущей даты в `TG_TZ`:

- "на этой неделе"
  - диапазон: от сегодня до следующего понедельника (exclusive)
- "на следующей неделе"
  - диапазон: от следующего понедельника до понедельника через неделю (exclusive)

Поведение как у Social списков:

- в список попадают задачи, у которых `Due Date` попадает в диапазон
- плюс всегда добавляется `Inbox` (даже если у задач из Inbox нет due date)
- другие задачи без due date в недельные списки не включаются

Поддерживаемые формулировки (примеры):

- "покажи задачи на этой неделе"
- "покажи задачи на эту неделю"
- "покажи задачи на текущую неделю"
- "покажи задачи на следующей неделе"

### Дата и время (важно)

- AI планер получает контекст времени:
  - текущий момент (UTC ISO)
  - текущий момент в `TG_TZ`
  - сам `TG_TZ`
- При создании задачи бот старается извлечь due date из текста пользователя детерминированно:
  - "сегодня/завтра/послезавтра" выставляются по `TG_TZ`
  - "сегодня в 15:00" превращается в ISO datetime с оффсетом (например `YYYY-MM-DDT15:00:00+03:00`)
- Это сделано, чтобы избежать двух классов ошибок:
  - модель "придумала" не тот день (например 2024 год)
  - сдвиг времени из-за интерпретации UTC против локального времени

## Контекст для planner (memory, chat, work)

Перед вызовом planner бот может подмешивать контекст:

- Memory summary (preferences) - из Postgres `preferences`
- Chat summary и recent messages - из Postgres `chat_summaries` и `chat_messages`
- Work context - компактный контекст из Notion (Tasks, Ideas, Social), который воркер кладет в Postgres `work_context_cache`

Work context подмешивается не всегда:

- `TG_WORK_CONTEXT_MODE=auto` - только для сообщений "обсуждение/планирование" по эвристике
- `TG_WORK_CONTEXT_MODE=always` - всегда
- `TG_WORK_CONTEXT_MODE=off` - никогда

## Валидация и нормализация Notion полей

Перед отправкой данных в Notion бот валидирует и нормализует значения:

- Статусы и select/multi_select поля: сопоставляются с существующими options, некорректные значения отбрасываются или нормализуются.
- Это предотвращает ошибки `HTTP 400 validation_error` от Notion API.

## Ideas DB и Social Media Planner

### Ideas DB

- Создание, просмотр и обновление идей идет через отдельный репозиторий Ideas DB.
- "Удалить идею" означает архивировать страницу (Notion `archived=true`).
- Повторное архивирование уже архивированной идеи не вызывает ошибку: бот отвечает "Похоже, эта идея уже в архиве."
- Категория `Category` считается стабильной сущностью:
  - бот старается **переиспользовать существующие** значения из Notion options
  - бот **не должен плодить** новые категории по ошибке (например из-за неточного STT или перефразирования)
  - если категория не совпадает с существующими options, бот либо оставит категорию пустой, либо положит в `Concept` (если такая категория существует)
  - поля вроде `Area` и `Source` можно заполнять более свободно
  - `Area`:
    - если `Area` в Notion это `select` или `multi_select`, бот сначала пытается сметчить к существующим options
    - если подходящей опции нет, бот может создать новую option для `Area` (без дублей) и проставить ее
- Теги (`Tags`): при обновлении идеи теги по умолчанию **добавляются** к существующим (merge), а не заменяют их. Чтобы заменить теги, нужно явно попросить "замени теги" или "поставь теги X" (без слова "добавь").

### Social Media Planner

- Создание и просмотр постов идет через Social Media Planner DB.
- "Удалить пост" означает архивировать страницу (Notion `archived=true`).
- Если при создании поста не указан `Platform`, бот попросит выбрать платформу кнопками.
- Если `Platform` указан неточно (например "фейсбук/facebook/fb"), бот попробует сметчить по существующим Notion options и только если не получилось - попросит выбрать кнопками.
- Если указана неподдерживаемая платформа (не совпадает с существующими options), бот просит выбрать из доступных кнопками (вместо ошибки "Не понял платформу").
- Если пользователь говорит дату вроде "сегодня/завтра/послезавтра", бот пытается автоматически проставить `Post date` при создании поста.

#### Списки постов "к публикации" (по датам и неделям)

Для запросов с датой или диапазоном бот считает, что речь о постах "к публикации" и применяет более строгие фильтры:

- показывает только посты с заполненным `Post date`
- по умолчанию исключает статусы: `Published`, `Cancelled`

Поддерживаемые формулировки:

- "покажи посты на завтра" - фильтр по одному дню \([tomorrow, tomorrow+1)\)
- "покажи посты на 8-е" / "на восьмое" - фильтр по одному дню \([date, date+1)\), дата считается как ближайшее наступление числа месяца
- "покажи посты на этой неделе" / "на эту неделю" / "до конца недели" - фильтр по диапазону от сегодня до следующего понедельника (exclusive), в `TG_TZ`

Примечание:

- Если пользователь явно просит "опубликованные" или "отмененные", бот может не исключать `Published` или `Cancelled` соответственно.

## Journal (личный дневник)

- Создание и просмотр записей идет через Journal DB.
- "Удалить запись дневника" означает архивировать страницу (Notion `archived=true`).
- Поля `Type`, `Topics`, `Context` считаются стабильными:
  - бот сначала сопоставляет с существующими значениями
  - если подходящего значения нет, бот может создать новый option (без дублей, по нормализации)
- При создании записи дневника бот **обязательно** заполняет:
  - `Type`
  - `Topics` (минимум 1)
  - `Context` (минимум 1)
  - `Mood` и `Energy` как числа **1-5** (если уверенности нет, ставит нейтральные `3/3`)

## Флаги запуска

- `TG_AI=1` - включает AI ветку.
- `TG_AI_MODEL=gpt-4.1` - модель для AI (по умолчанию в коде используется `gpt-4.1` если переменная не задана).
- `TG_DEBUG=1` - включает `[tg_debug]` логи.


